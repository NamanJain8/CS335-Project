Created by PLY version 3.11 (http://www.dabeaz.com/ply)

Unused terminals:

    ADD
    ADD_ASSIGN
    AND
    AND_ASSIGN
    AND_NOT
    AND_NOT_ASSIGN
    ARROW
    BREAK
    CASE
    CHAN
    CHAR
    COLON
    COMMA
    CONST
    CONTINUE
    DEC
    DEFAULT
    DEFER
    DEFINE
    ELLIPSIS
    ELSE
    FALLTHROUGH
    FLOAT
    FUNC
    GEQ
    GO
    GOTO
    GTR
    IF
    IMAG
    IMPORT
    INC
    INTERFACE
    LAND
    LBRACK
    LEQ
    LOR
    LSS
    MAP
    MUL
    MUL_ASSIGN
    NEQ
    NOT
    OR
    OR_ASSIGN
    PACKAGE
    PERIOD
    QUO
    QUO_ASSIGN
    RANGE
    RBRACK
    REM
    REM_ASSIGN
    RETURN
    SELECT
    SHL
    SHL_ASSIGN
    SHR
    SHR_ASSIGN
    STRING
    STRUCT
    SUB
    SUB_ASSIGN
    SWITCH
    TYPE
    VAR
    XOR
    XOR_ASSIGN

Grammar

Rule 0     S' -> ForLoop
Rule 1     ForLoop -> FOR LPAREN cond RPAREN LBRACE stmt RBRACE
Rule 2     cond -> IDENT EQL INT
Rule 3     cond -> empty
Rule 4     stmt -> IDENT ASSIGN IDENT SEMICOLON
Rule 5     empty -> <empty>

Terminals, with rules where they appear

ADD                  : 
ADD_ASSIGN           : 
AND                  : 
AND_ASSIGN           : 
AND_NOT              : 
AND_NOT_ASSIGN       : 
ARROW                : 
ASSIGN               : 4
BREAK                : 
CASE                 : 
CHAN                 : 
CHAR                 : 
COLON                : 
COMMA                : 
CONST                : 
CONTINUE             : 
DEC                  : 
DEFAULT              : 
DEFER                : 
DEFINE               : 
ELLIPSIS             : 
ELSE                 : 
EQL                  : 2
FALLTHROUGH          : 
FLOAT                : 
FOR                  : 1
FUNC                 : 
GEQ                  : 
GO                   : 
GOTO                 : 
GTR                  : 
IDENT                : 2 4 4
IF                   : 
IMAG                 : 
IMPORT               : 
INC                  : 
INT                  : 2
INTERFACE            : 
LAND                 : 
LBRACE               : 1
LBRACK               : 
LEQ                  : 
LOR                  : 
LPAREN               : 1
LSS                  : 
MAP                  : 
MUL                  : 
MUL_ASSIGN           : 
NEQ                  : 
NOT                  : 
OR                   : 
OR_ASSIGN            : 
PACKAGE              : 
PERIOD               : 
QUO                  : 
QUO_ASSIGN           : 
RANGE                : 
RBRACE               : 1
RBRACK               : 
REM                  : 
REM_ASSIGN           : 
RETURN               : 
RPAREN               : 1
SELECT               : 
SEMICOLON            : 4
SHL                  : 
SHL_ASSIGN           : 
SHR                  : 
SHR_ASSIGN           : 
STRING               : 
STRUCT               : 
SUB                  : 
SUB_ASSIGN           : 
SWITCH               : 
TYPE                 : 
VAR                  : 
XOR                  : 
XOR_ASSIGN           : 
error                : 

Nonterminals, with rules where they appear

ForLoop              : 0
cond                 : 1
empty                : 3
stmt                 : 1

Parsing method: LALR

state 0

    (0) S' -> . ForLoop
    (1) ForLoop -> . FOR LPAREN cond RPAREN LBRACE stmt RBRACE

    FOR             shift and go to state 2

    ForLoop                        shift and go to state 1

state 1

    (0) S' -> ForLoop .



state 2

    (1) ForLoop -> FOR . LPAREN cond RPAREN LBRACE stmt RBRACE

    LPAREN          shift and go to state 3


state 3

    (1) ForLoop -> FOR LPAREN . cond RPAREN LBRACE stmt RBRACE
    (2) cond -> . IDENT EQL INT
    (3) cond -> . empty
    (5) empty -> .

    IDENT           shift and go to state 5
    RPAREN          reduce using rule 5 (empty -> .)

    cond                           shift and go to state 4
    empty                          shift and go to state 6

state 4

    (1) ForLoop -> FOR LPAREN cond . RPAREN LBRACE stmt RBRACE

    RPAREN          shift and go to state 7


state 5

    (2) cond -> IDENT . EQL INT

    EQL             shift and go to state 8


state 6

    (3) cond -> empty .

    RPAREN          reduce using rule 3 (cond -> empty .)


state 7

    (1) ForLoop -> FOR LPAREN cond RPAREN . LBRACE stmt RBRACE

    LBRACE          shift and go to state 9


state 8

    (2) cond -> IDENT EQL . INT

    INT             shift and go to state 10


state 9

    (1) ForLoop -> FOR LPAREN cond RPAREN LBRACE . stmt RBRACE
    (4) stmt -> . IDENT ASSIGN IDENT SEMICOLON

    IDENT           shift and go to state 12

    stmt                           shift and go to state 11

state 10

    (2) cond -> IDENT EQL INT .

    RPAREN          reduce using rule 2 (cond -> IDENT EQL INT .)


state 11

    (1) ForLoop -> FOR LPAREN cond RPAREN LBRACE stmt . RBRACE

    RBRACE          shift and go to state 13


state 12

    (4) stmt -> IDENT . ASSIGN IDENT SEMICOLON

    ASSIGN          shift and go to state 14


state 13

    (1) ForLoop -> FOR LPAREN cond RPAREN LBRACE stmt RBRACE .

    $end            reduce using rule 1 (ForLoop -> FOR LPAREN cond RPAREN LBRACE stmt RBRACE .)


state 14

    (4) stmt -> IDENT ASSIGN . IDENT SEMICOLON

    IDENT           shift and go to state 15


state 15

    (4) stmt -> IDENT ASSIGN IDENT . SEMICOLON

    SEMICOLON       shift and go to state 16


state 16

    (4) stmt -> IDENT ASSIGN IDENT SEMICOLON .

    RBRACE          reduce using rule 4 (stmt -> IDENT ASSIGN IDENT SEMICOLON .)

